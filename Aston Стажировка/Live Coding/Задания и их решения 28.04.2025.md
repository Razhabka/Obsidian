### 1. **Найти сумму четных чисел массива**

> Дан массив `int[] arr = {1, 2, 3, 4, 5, 6}`.  
> Найти сумму **только четных чисел**.

✅ (ожидаемый результат: `2 + 4 + 6 = 12`)

```
public static void main(String[] args) {  
    int[] arr = {1, 2, 3, 4, 5, 6};  
  
    System.out.println(sumOddNums(arr));  
}  
  
public static int sumOddNums(int[] nums){  
    return Arrays.stream(nums).filter(x -> x % 2 == 0).sum();  
}
```

### 2. **Вытащить строки длиной больше 3 символов**

> Дан список строк:  
> `List<String> list = List.of("cat", "dog", "elephant", "bee");`

Оставить только строки, длина которых **больше 3**.

✅ (ожидаемый результат: `["elephant"]`)

```
public static void main(String[] args) {  
    List<String> list = List.of("cat", "dog", "elephant", "bee");  
    System.out.println(bolsheTrex(list));  
}  
  
public static List<String> bolsheTrex(List<String> lst){  
    return lst.stream().filter(x -> x.length() > 3).toList();  
}
```

### 3. **Проверить, содержится ли в списке хотя бы одно отрицательное число**

> Дан список чисел:  
> `List<Integer> numbers = List.of(1, 2, 3, -4, 5);`

Нужно вернуть `true`, если в списке есть хотя бы один элемент `< 0`.

```
public static void main(String[] args) {  
    List<Integer> numbers = List.of(1, 2, 3, -4, 5);  
    System.out.println(isOtricat(numbers));  
}  
  
public static boolean isOtricat(List<Integer> lst){  
    return lst.stream().anyMatch(x -> x < 0);  
}
```
### 4. **Преобразовать список строк в список их длин**

> Пример:  
> `List<String> words = List.of("apple", "banana", "kiwi");`

Сформировать список: `[5, 6, 4]`  
(где 5 — длина `"apple"`, 6 — `"banana"`, 4 — `"kiwi"`)\

```
public static void main(String[] args) {  
    List<String> words = List.of("apple", "banana", "kiwi");  
    System.out.println(allLength(words));  
}  
  
public static List<Integer> allLength(List<String> lst){  
    return lst.stream().mapToInt(x -> x.length()).boxed().toList();  
}
```

### 5. **Получить строку из всех уникальных букв**

> Дан список строк:  
> `List<String> words = List.of("apple", "banana");`

Нужно получить **строку из всех уникальных букв**, отсортированных по алфавиту.  
✅ (ожидаемый результат: `"abelnp"`)

```
public static void main(String[] args) {  
    List<String> words = List.of("apple", "banana");  
    System.out.println(onlyUnique(words));  
}  
  
public static String onlyUnique(List<String> lst){  
    return lst.stream().collect(Collectors.joining()).chars().mapToObj(x -> (char)x).distinct().sorted().map(String::valueOf).collect(Collectors.joining());  
}
```

---
### 6. **Группировка строк по первой букве**

> Дан список строк:  
> `List<String> words = List.of("apple", "banana", "apricot", "blueberry", "avocado");`

**Нужно сгруппировать строки по первой букве**.  
Вернуть `Map<Character, List<String>>`, где ключ — первая буква, значение — список строк.

✅ Ожидаемый результат:
```
{
  a = [apple, apricot, avocado],
  b = [banana, blueberry]
}
```

```
public static void main(String[] args) {  
    List<String> words = List.of("apple", "banana", "apricot", "blueberry", "avocado");  
    System.out.println(groupingByWord(words));  
}  
  
public static Map<Character, List<String>> groupingByWord(List<String> lst){  
    return lst  
            .stream()  
            .collect(Collectors.groupingBy(  
                    word -> word.charAt(0)
```


### 7. **Подсчитать количество уникальных слов в списке строк**

> Дан список предложений:  
> `List<String> sentences = List.of("Java is great", "Java is powerful", "Java is popular");`

**Нужно найти общее количество уникальных слов** без учёта регистра.

✅ Ожидаемый результат для примера:  
(уникальные слова: `java`, `is`, `great`, `powerful`, `popular`) → **5**

```
public static void main(String[] args) {  
    List<String> sentences = List.of("Java is great", "Java is powerful", "Java is popular");  
    System.out.println(countUniqueWords(sentences));  
}  
  
public static Long countUniqueWords(List<String> lst){  
    return lst  
            .stream().flatMap( x -> Arrays.stream(x.split(" ")))  
            .map(String::toLowerCase)  
            .distinct()  
            .count();  
}
```

### 9. **Найти второе максимальное число в списке**

> Дан список чисел:  
> `List<Integer> numbers = List.of(5, 9, 1, 8, 6);`

**Найти второе по величине число.**  
(Если чисел меньше двух — бросить исключение или вернуть `Optional.empty()`.)

✅ Ожидаемый результат:

- Второе максимальное число: **8**
```
public static void main(String[] args) {  
    List<Integer> numbers = List.of(5, 9, 1, 8, 6);  
    System.out.println(secondMaxNums(numbers));  
}  
  
public static int secondMaxNums(List<Integer> lst){  
    return lst  
            .stream().sorted(Comparator.reverseOrder()).skip(1).findFirst().get();  
}
```

### 10. **Найти общее количество всех букв в списке строк**

> Дан список строк:
> `List<String> words = List.of("Java", "Stream", "Collectors");`
> **Нужно посчитать общее количество всех букв во всех строках.**  

(Пробелов нет, спецсимволов тоже нет.)

✅ Например:  
"Java" (4) + "Stream" (6) + "Collectors" (10) → 20

```
public static void main(String[] args) {  
    List<String> words = List.of("Java", "Stream", "Collectors");  
    System.out.println(countChar(words));  
}  
  
public static Long countChar(List<String> lst){  
    return lst  
            .stream().collect(Collectors.joining()).chars().count();  
}
```


### 11. **Проверить, все ли строки начинаются с заглавной буквы**

> Дан список строк:

`List<String> words = List.of("Java", "Python", "Stream");`
**Нужно проверить, что каждая строка начинается с заглавной буквы.**  
Вернуть `true`, если это так.

```
public static void main(String[] args) {  
    List<String> words = List.of("Java", "Python", "Stream");  
    System.out.println(allIsFirstChar(words));  
}  
  
public static boolean allIsFirstChar(List<String> lst){  
    return lst  
            .stream().allMatch(x -> Character.isUpperCase(x.charAt(0)));  
}
```

### 12. **Найти топ-3 самых длинных строк**

> Дан список строк:

`List<String> words = List.of("Java", "Stream", "Collectors", "Awesome", "API", "Practice");`
**Нужно вернуть список из 3 самых длинных строк**, отсортированных по убыванию длины.

✅ Пример результата:  
`["Collectors", "Practice", "Stream"]`

```
public static void main(String[] args) {  
    List<String> words = List.of("Java", "Stream", "Collectors", "Awesome", "API", "Practice");  
    System.out.println(allIsFirstChar(words));  
}  
  
public static List<String> allIsFirstChar(List<String> lst){  
    return lst  
            .stream().sorted(Comparator.comparingInt(String::length).reversed()).limit(3).map(String::valueOf).toList();  
}
```

### 13. **Сгруппировать числа по чётности**

> Дан список чисел:

`List<Integer> numbers = List.of(1, 2, 3, 4, 5, 6, 7, 8);`
`Нужно сгруппировать их в Map<Boolean, List<Integer>>`, где:
- `true` → список чётных чисел,
- `false` → список нечётных чисел.
```
public static void main(String[] args) {  
    List<Integer> numbers = List.of(1, 2, 3, 4, 5, 6, 7, 8);  
    System.out.println(groupingByOdd(numbers));  
}  
  
public static Map<Boolean, List<Integer>> groupingByOdd(List<Integer> lst){  
    return lst  
            .stream().collect(Collectors.groupingBy(  
                    x -> x % 2 ==0  
            ));  
}
```

### 14. **Найти самое длинное слово в списке, если оно есть**

> Дан список строк:

`List<String> words = List.of("stream", "api", "collectors", "java");`
**Нужно найти самое длинное слово.**  
Вернуть его через `Optional<String>`, потому что список может быть пустым.

✅ Например:

- В данном случае: `"collectors"`
- Если список пустой → вернуть `Optional.empty()`
```
public static void main(String[] args) {  
    List<String> words = List.of("stream", "api", "collectors", "java");  
    System.out.println(groupingByOdd(words));  
}  
  
public static Optional<String> groupingByOdd(List<String> lst){  
    return lst  
            .stream().sorted(Comparator.comparingInt(String::length).reversed()).limit(1)
            .findFirst();  
}
```

### 14. **Собрать все уникальные буквы из списка строк в отсортированное множество**

> Дан список:

`List<String> words = List.of("apple", "banana", "cherry");`
**Нужно получить `Set<Character>`, который содержит все уникальные буквы из всех строк, отсортированные по алфавиту.**

✅ Например:  
Результат будет: `[a, b, c, e, h, l, n, p, r, y]`

```
public static void main(String[] args) {  
    List<String> words = List.of("apple", "banana", "cherry");  
    System.out.println(groupingByOdd(words));  
}  
  
public static List<Character> groupingByOdd(List<String> lst){  
    return lst  
            .stream().collect(Collectors.joining())  
            .toLowerCase().replaceAll(" ", "")  
            .chars().mapToObj(x -> (char)x)  
            .distinct()  
            .sorted()  
            .toList();  
}
```