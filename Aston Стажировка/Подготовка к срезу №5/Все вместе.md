## 1. Ответы на вопросы(Основы теории по автоматизации)

#### 1. Общая классификация тестирования 


#### 2. Что такое автоматизация тестирования
Это процесс, который позволяет писать тесты на языке программирования, используя при этом определенный набор техник
Зачем?
1. Ускорить тестирование
2. Уменьшить человеческие ошибки
3. Проверять то, что сложно тестировать в ручную
4. Сэкономить деньги
5. Делать стабильные проверки


#### 3. Основные принципы и цели автоматизации
Принципы: 
1. Автоматизировать не все
	- Что стоит автоматизировать(Частые проверки, сложные сценарии)
	- Что не стоит автоматизировать(Тесты которые редко выполняются, проверка пользовательского опыта, тесты который часто меняются)
2. Писать стабильные тесты
	- Тесты должны работать, даже при небольших изменениях в UI
3. Поддерживать тесты в актуальном состоянии
4. Использовать подходящие инструменты
5. Интегрировать автоматизацию в процесс разработки 

**Цели:**
1. Сократить время тестирования
2. Снизить нагрузку на специалиста 
3. Обеспечить надежность выполнения тестирования
4. Ускорить процесс тестирования
5. Улучшить тестовое покрытие 
6. Сократить ручное вмешательство
7. Экономия времени на регресе

#### 4. Зачем нужна автоматизация
**Цели:**
1. Сократить время тестирования
2. Снизить нагрузку на специалиста 
3. Обеспечить надежность выполнения тестирования
4. Ускорить процесс тестирования
5. Улучшить тестовое покрытие 
6. Сократить ручное вмешательство
7. Экономия времени на регресе


#### 5. Пирамида тестирования с примерами на проектах

1. Модульное тестирование(Unit-тесты) - тестируется отдельная функциональность, ее пишул разработчики
2. Интеграционное тестирование - взаимодействие модулей/сервисов, RestAssured
3. Системное тестирование(E2E) - полный сценарий от начала до конца
4. Приемочное тестирование - Тестирование всей функциональности

#### 6. Практическое применение E2E-фигуры

#### 7. Что следует автоматизировать 
1. Бизнес-критические пути
2. Тесты, которые должны прогоняться на каждом билде 
3. Тесты, которые нужно погонять на разных кофигурациях
4. Тесты, которые используют один и тот же сценарий 
5. Тесты, которые завязаны на больших объемах данных 
6. Которые занимают много времени
7. Тесты, где необходим захват изображения

#### 8. Тесты, который не должны быть автоматизированы
1. Тесты, которые прогоняются один раз
2. Тесты, пользовательского опыта
3. Срочные тесты
4. Прерывающиеся тесты
5. Тесты, требующие визуального подтверждения
6. Тесты, которые не могут быть автоматизированы на 100% 


#### 9. Тестовая фигура для frontend-проекта

Это проверка GUI, то есть все что видно на экране на стороне клиента. Для веб приложения интерфейсное тестирование включает проверку функциональных возможностей, таких как форм, графики, меню, отчеты
Фигура:
1. E2E-тесты - Проверяют приложение с точки зрения конечного пользователя
2. Интеграционные - Проверят слаженное функционирование нескольких взятых вместе модулей, делает упор на дизайн, что в свою очередь упрощает изменение кода
3. Юнит-тесты - Пишутся быстро и легко запускаются. Проверяют отдельные модули на их работоспособность
4. Статичные - Самые простые, нацелены на выявление проблем в несоответветствии типов, стилистических проблем и ошибок форматирования


#### 10. Тестовая фигура для backend-проекта 
Это тип тестирования, который проверяет уровень приложения и БД 3-х уровневой архитектуры
Для данного вида тестирования, наиболее оптимальное решение - классическая пирамида тестирования 
1. User interface test 
2. API test
3. unit test 


## 2. Ответы на вопросы(Системы контроля версий (Git, tfs...))

#### 1. Система контроля версии, базовое понимание git, gitflow
Система управления версиями - программное обеспечение для облегчения работы с изменяющейся информацией. Позволяет хранить несколько версий одного и того же документа, при необходимости возвращаться к более ранним версиям
**Она позволяет:**
1. Видеть, кто и когда вносил изменения
2. Возвращаться к любой прошлой версии
3. Работать над разными модулями одновременно

**GIT** - Самая популярная система контроля версии
**Базовые команды**
**git config** - настройка
**git init** - создать новый проект в текущей директории
**git clone** {*URL*} - копирует удаленный репозиторий
**git status** - показывает измененные файлы
**git add** {*файл*} - добавить файл в зону подготовки
**git commit** -m {*описание изменений*} - сохраняет изменения
**git log** - история коммитов
**git branch** - список веток
**git branch** {*имя*} - создать новую ветку
**git checkout** {*имя*} - переключиться на ветку
**git checkout -b** {*имя*} - создать и переключиться на ветку
**git pull** - забирает изменения с сервера
**git push** - отправляет все изменения на сервер

**Gitflow** - это правила для удобной работы с git в команде
Основные ветки: 
1. main/master - стабильная вресия проекта
2. dev - текущая разрабатываемая ветка
3. featute - ветки новой функциональности
4. release - подготовка к выпуску
5. hotfix - срочные исправления


#### 2. fetch, ветвление, tagging, слияние изменений из ветки

**git fetch** - Загрузка изменений с сервера без слияний
Она скачивает свежие изменения из удаленного репозитория но не применяет их к твоей рабочей копии
Она безопаснее чем git pull, так как сначала позволяет проверить изменения

**Ветвление** - Позволяет работать над разными задачами параллельно
git branch
git checkout

**taging** - помечает важные версии 
**git tag** - показывает список тегов
**git checkout {v1.0.0}** позволяет переключиться на версии по тегу

**Слияние** - Позволяет перенести все изменения из одной ветки в другую
**git checkout {*main*}** - переключение на ветку, КУДА сливаем
**git merge{*name_branch*}** - Сливаем ветку "*name_branch*" в "*main*"


#### 3. Blaming (annotate)
**git blame** - это команда показывает, кто последним редактировал каждую строку в файле, когда это было сделано и в каком коммите
Нужно:
1. найти автора кода
2. узнать почему была сделана определённая правка 
3. Разобраться в истории изменений сложного файла

#### 4. Команды reset, revert
Обе команды отменяют изменения, но делают это по разному

**git reset** - отменяет коммиты(ОПАСНО!!!)
Удаляет коммиты из истории
Перемещает указатель ветки на выбранный коммит

**git revert** - безопасная отмена
Создает новый коммит, который отменяет изменения выбранного коммита
Не переписывает историю(безопасно для работы в команде)


#### 5. cherry-pick
**git cherry-pick** - перенос конкретного коммита в другую ветку

Позволяет взять один конкретный коммит из любой ветки и применить его к текущей ветке

Используется для:
1. Перенос исправленного бага
2. Восстановление потерянного коммита 
3. Выборочное применение изменений 

## 3. Ответы на вопросы (CI, CD)

#### 1. Что такое CI/CD
Это способ автоматизировать процесс разработки, тестирования и доставки кода, чтобы программисты могли быстрее и надежнее выпускать код

##### CI - непрерывная интеграция, она автоматически проверят, что новый код не сломал старый 
Как работает:
1. программист загружает код в репозиторий 
2. СI  запускает автоматические проверки 
	- Собирается ли проект
	- Проходят ли тесты
3. Если что-то пошло не так - система сообщает об ошибке

###### CD - Непрерывная доставка, после прохождения CI автоматически разворачивает готовый код на сервере 
- Continuius Delivery - код можно в любой момент выпустить в продакшн (но это делает вучную)
- Continuius Deployment - код автоматически попадает в продакшн, если прошел все проверки
Как работает:
1. После проверки CI что код рабочитй
2. CD разворачивает его:
	- На тестовый сервер
	- На прод


#### 2. Что такое контейнеризация и виртуализация
Они помогают создавать стабильные и переносимые среды для сборки, тестирования и развертывания приложений, но решают разные задачи

**Виртуализация** - могут запускать сборки и тесты внутри ВМ, каждая задача выполняется на отдельной ВМ, что обеспечивает полную изоляцию


| Плюсы                          | Минусы                  |
| ------------------------------ | ----------------------- |
| Полная изоляция                | Долгий запуск           |
| Можно тестировать на разных ОС | Требует больше ресурсов |
**Контейнеризация** - Вместо ВМ используют контейнеры, CI/CD-пайплайн запускает каждый этап на отдельных контейнерах


| Плюсы                                     | Минусы                                                                     |
| ----------------------------------------- | -------------------------------------------------------------------------- |
| Быстрый старт                             | Меньшая изоляция чем у ВМ                                                  |
| Легковесность(Не нужно копировать всю ОС) | Ограничение по ОС(Нельзя запускать приложения Windows в контейнерах Linux) |
| Идентичное окружение на всех этапах CI/CD |                                                                            |


#### 3. CI/CD-цикл
1. Разработка - программист пишет код и делает коммит в Git
2. Непрерывная интеграция - при пуше кода в репозиторий запускает автоматическая сборка и тестирование
	- Код клонируется в чистое окружение 
	- Запускаются юнит-тесты
	- Если тесты не проходят разработчик получает уведомление 
3. Если тесты пройдены, код собирается в готовый артефакт(бинарник, docker-образ)
4. Непрерывная доставка - артефакт разворачивается в тестовом окружении, в нем производятся дополнительные проверки
5. Непрерывное развертывание - если все тесты пройдены, код автоматически попадает в продакшн
6. Мониторинг и откат - После деплоя системы мониторинга следит за ошибками, если что-то сломалось автоматический откат на предыдущую версию. Он должен быть непрерывным

#### 4. Continuos Delivery и Continuos Deployment
- Continuius Delivery - код можно в любой момент выпустить в продакшн (но это делает вучную)
- Continuius Deployment - код автоматически попадает в продакшн, если прошел все проверки


#### 5. Docker базовое понимание 
Docker - это платформа для контейнеризации приложений. Она позволяет упаковывать программу со всеми ее зависимостями в изолированный контейнер, который можно запускать на любой системе, где установлен докер

1. Образ image - это шаблон для создания контейнера
	- ОС
	- Установленные программы
	- Выше приложение 
2. Контейнер - это запушенный экземпляр образа
3. Dockerfile - текстовый файл с инструкциями для образа 