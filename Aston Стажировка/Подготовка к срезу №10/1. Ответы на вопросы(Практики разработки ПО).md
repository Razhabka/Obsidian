#### 1. KISS, DRY YAGNI
1. **KISS** (Keep It Simple Stupid)
	- Суть - Стремитесь к простоте в проектировании и реализации. Идея заключается в том, что излишнее сложные решения часто приводят к ошибкам и затрудняют поддержку
2. **DRY**(Don't Repeat Yourself)
	- Суть: Избегайте дублирования кода и логики. Каждый фрагмент знаний в системе должен иметь единственное однозначное представления
3. **YAGNI**
	- Суть: Не стоит реализовывать функциональность пока она не понадобиться. То есть, не нужно строить архитектуру с огромным числом возможностей, которые могут никогда не использоваться 
#### 2. SOLID
1. **S - Single responsibility prncipe**
	- Один класс должен отвечать только за одну конкретную задачу
		- - Класс `DriverManager` отвечает только за инициализацию WebDriver.
		- `LoginPage` — только за действия на странице логина.
		- `LoginTests` — только за тест-кейсы.
2. **O - Open/Closed**
	- Классы должны быть открыты для расширения, но закрыты для изминения
		- Добавление нового браузера в `DriverFactory` без изменения кода класса, а через реализацию нового класса `EdgeDriverProvider`, например.
		- Использование `@Listeners` или хуков в TestNG без изменения основной логики тестов.
3. **L**
	- Подклассы не должны ломать поведения базового класса 
		- Если у вас есть абстрактный класс `BasePage`, все страницы, которые его наследуют (`LoginPage`, `ProfilePage`), должны корректно работать при подстановке туда, где используется `BasePage`.
4. **I** (Лучше много маленьких интерфейсов, чем один огромный)
	- Разделение интерфейсов по смыслу, чтобы классы не реализовывали лишнего
		- Вместо одного интерфейса `ITestActions`, содержащего все возможные действия, лучше создать более узкие
		- `IClickable`, `IVisible`, `IInputable` — для разделения обязанностей в Page Object-слое.
5. **D** - Не завись от конкретных реализаций используй абстракции
	- Зависеть нужно от интерфейсов, а не от конкретных классов
		- Зависимости внедряются через конструкторы (инъекция зависимостей).
		- Например: `TestExecutor` получает `ITestRunner`, а не `TestNGRunner` напрямую.

#### 3. ФП
ФП - это парадигма, при которой программы строятся из функций. Вместо изменений состояний и явных циклов - выстраивается поток преобразования данных через функции 

Принципы:
1. Иммутабельность - данные не изменяются в создаются новые копии
2. Чисты функции - Нет побочных эффектов(не зависят от внешнего мира)
3. Функция как значение - Функции можно передавать, возвращать сохранять
4. Декларативность - Описание "Что нужно", а не "как именно делать"
5. Композиция функции - Складывание функции в цепочки обработки 

| Интерфейс               | Когда использовать                                                 | Пояснение                                                       | Пример                                          |
| ----------------------- | ------------------------------------------------------------------ | --------------------------------------------------------------- | ----------------------------------------------- |
| **Consumer<T>**         | Когда нужно **что-то сделать с объектом**, но ничего не возвращать | Выполняет действие над объектом                                 | `forEach`, `peek`, `thenAccept`                 |
| **Supplier<T>**         | Когда нужно **получить/сгенерировать значение без входных данных** | Создание или поставка значений                                  | `supplyAsync`, ленивые генераторы               |
| **Function<T, R>**      | Когда нужно **преобразовать один объект в другой**                 | Преобразование одного типа в другой                             | `map`, `computeIfAbsent`, `thenApply`           |
| **Predicate<T>**        | Когда нужно **проверить условие** (да/нет) над объектом            | Проверка условий и фильтрация                                   | `filter`, `removeIf`, `anyMatch`                